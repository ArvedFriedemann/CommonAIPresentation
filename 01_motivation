Common Artificial Intelligence : A New Technology

Major breakthroughs happen rarely, especially in fields as well worked on as computer science. Still, sometimes it occurs that old ideas re-emerge when the time of their technical practicality has come. I am Arved and during the course of my PhD, I found a technology that poses a solution to all computer science problems. I found a way to lower the construction time of a key technology from millions of years down to a few years of advanced engineering. I hope to inspire researchers and software engineers alike to to help me implement this last step of information technology and to create a new network uniting computer science.
The technology I am talking about is common artificial intelligence, or as I will often refer them to, universally optimal solvers.

This research combines the results of proof theory and symbolic logic, esp. logical programming. It has long been known that, with a sufficiently strong proof system, any optimal solving system could be found. However, it hasn't been practically possible until recently logical programming made tools and theories available that can reduce the enumeration of proofs to a minimum. I found a way how to use these tools and theories to create something I refer to as a self improving solver.

A quick introduction to the technology. We assume an immutable but possibly partial known memory. This memory contains all information, which can also be referred to as knowledge. Thanks to results in proof and especially type theory, we can give this knowledge readable names represented as terms. We will dive into the details of how this is done later, but for now, imagine a computer working in a way that initially, some information is known, which can trigger new information to be deduced until finally, no new knowledge can be inferred. You can imagine that this does not work like the sequential languages that you might be used to. The programs that live in this memory get executed normally, until the values they need for further execution are unassigned, resulting in them sleeping until the necessary values are deduced from another point. A concurrent process. This enables us to look at programs more as things that produce information based on observation, and this information is available wherever needed by all other programs. If one program does not succeed in finding the answer, another one eventually might, continuing the process. Furthermore, this makes it possible to run programs where we only partially know how they look like. They are just executed until the point that they need something and then freeze in their advanced state.

And both of these viewpoints make the last puzzle piece possible. A program that can rewrite itself while it runs. It is quite easily expressed. A partially known program can reference the variables it is itself stored in and make deductions about them. Some programs deduce themselves fast enough to always run, others don't, and they can be kickstarted from outside. In this research, we will explore a concrete way to use this behaviour to create self improving solving systems and make sure they can run without help from outside.

This does not necessarily mean that they don't profit from external input. In fact, these frozen programs can be seen as unevaluated disjunctions, as are often used in interactive theorem provers. A user could look into the current state of the program and assign some values themselves, which triggers the sleeping programs to reawaken and start running. Imagine what happens now when you work on the automated prover that helps you find deductions quicker. Every time you deduce something about it, it is immediately executed and the proof search becomes quicker. And now think further. What happens if we apply this automated solver to its own construction?

Such a self improving interactive theorem prover would already have huge impacts on computer science. Programs could be more and more autonomously created and we would not need to solve any repetitive task any more, because every solution we find is immediately translated into a program. And if we now link all these deductions we are making, such that they are shared between everyone using the system, it would be the fastest evolving program ever created.

In the next videos, I will talk about the details of how to implement this system and what formalisms are needed. It is not a large implementation, but still large enough to not be a task for a single person. I will give my best to teach how this technology works and hope to find researchers and engineers joining in to create optimal solvers and common artificial intelligence in a common act of collaboration.

In this time, it is exciting to be a computer scientist.
Thank you all for watching and feel free to comment on the content of this video. See you in the next episodes!
