Common Artificial Intelligence : A New Technology

Major breakthroughs happen rarely, especially in fields as well worked on as computer science. Still, sometimes it occurs that old ideas re-emerge when the time of their technical practicality has come. I am Arved, and during the course of my PhD, I found a technology that poses a solution to fundamental computer science problems. I found a way to lower the construction time of a key technology from millions of years down to a few years of advanced engineering. I hope to inspire researchers and software engineers alike to to help me implement this last step of information technology and to create a new network uniting computer science.
The technology I am talking about is common artificial intelligence, or as I will often refer them to, universally optimal solvers.

The idea came when I tried to get my machines to talk with me. It is easy to punch a grammar into your computer and do a depth first search to create correct sentences, but let's face it, the results are quite underwhelming. But writing with grammars in a somewhat natural language is personally rewarding, so I thought "Hey, why not write a better search procedure using only grammars as well?". How convenient that the problem of finding correct sentences is the same as finding a correct proof. And indeed, being a researcher in the area of proof and search systems, I found a technology that makes exactly that possible.

This research combines the results of proof theory and symbolic logic, esp. logical programming. It has long been known that, with a sufficiently strong proof system, any optimal solving system could be found. Just state "There exists an optimal prover", enumerate all proofs and hope for it to terminate. However, this hasn't been practically possible until recently logical programming made tools and theories available that can reduce this enumeration of proofs to a minimum. I found a way how to use these tools and theories to create something I refer to as self improving solvers.

A quick introduction to the technology. First thing we need is a proper way to organise knowledge. We assume an immutable but possibly partial known memory. This memory contains all information; assignments, the program...
Thanks to results in proof and especially type theory, we can give this knowledge readable names represented as terms. We will dive into the details of how this is done later, I will just hint that the mozart system and its oz language have this behaviour. For now, imagine a computer working in a way that initially, some information is known, which can trigger new information to be deduced until finally, no new knowledge can be inferred. Programs inside this memory can be executed like any other language, but with a twist. The programs that live in this memory run normally, until the values they need for further execution are unassigned, resulting in them sleeping until the necessary variables are deduced from another point. A concurrent process. This enables us to look at programs that are unfinished, without losing the ability to execute what's already there. At any point, we can even introduce some information either automatically or by hand and see how it develops. Furthermore, and this is the most important, due to the concurrent nature, every deducible knowledge can eventually be deduced, nothing gets left out.

This way of thinking about programs makes the deciding puzzle piece possible. A program that can rewrite itself while it runs. It is quite easily expressed. A partially known program can reference the variables it is itself stored in and make deductions about them. In the best case, programs deduce themselves fast enough to always run, others don't, and they can be kickstarted from outside. In this research, we will explore a concrete way to use this behaviour to create self improving solving systems and make sure they can run without help from outside.

There is an important connection into the area of proof assistants. The frozen programs can be seen as still open disjunctions, as are often used in interactive theorem provers. This is a direct connection into the highly collaborative area of interactive proof systems and will form the basis of information exchange.

What is new is that the choices the user or some external program makes immediately trigger new deductions by sleeping programs that now reawaken. Imagine what happens when you work on the automated prover that helps you find deductions quicker. Every time you deduce something about it, the new parts are immediately executed and the proof search becomes quicker. And now think further. What happens if we apply this automated solver to its own construction?

Such a self improving interactive theorem prover would already have huge impacts on computer science. Programs could be more and more autonomously created and we would not need to solve any repetitive task any more, because every solution we find is immediately translated into a program. And if we now link all these deductions we are making, such that they are shared between everyone using the system, it would be the fastest evolving program ever created.

In the next videos, I will talk about the details of how to implement this system and what formalisms are needed. It is not a large implementation, but still large enough to not be a task for a single person. I will give my best to teach how this technology works and hope to find researchers and engineers joining in to create optimal solvers and common artificial intelligence in a common act of collaboration.

In this time, it is exciting to be a computer scientist.
Thank you all for watching and feel free to comment on the content of this video. I hope you can enjoy the next episodes as well!
I am Arved, and see you soon
