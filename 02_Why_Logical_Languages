Why Logical Languages?

What we often forget in computer science is the initial feeling we had with computers. Weird looking machines that, as soon as black windows opened, we had no idea what they were telling us. Now we take the ability to read a programming language for granted, but let's take a step back and ask ourselves how we could create a language that is actually intuitively readable.

The one thing we can't really change about computers is how a memory works. A whole lot of boxes that exactly one thing fits in. There are boxes that we put the input in, there are other boxes we get the output out. Some magic inbetween. If we ever want anything to end up in our output boxes, we kind of need objects that put it there. We call these assignments.
An assignment copies content from one box into another. The assignment itself is also an object that contains the positions, or pointers, to the boxes it makes equal, so yeah, lets put it into some box of its own as well. As soon as we do so, and one of the target boxes is filled, the other box fills respectively.
Just plane assignments are kinda boring though, as they always assign the same value. Most of the time, we want an assignment to depend on some input. That is why there is a conditional assignment. This is an object that states that if some two assignments are equal, a target box should be equal to a box A, and if not to a box B. Last but not least, we need an object that can find new boxes to store in, but let's end the details here.

All of this is just what we need in order for a computer to do anything. But what does this have to do with nice languages? The reasons are grammars.

Grammars are used to model languages, no matter how natural they are. In these grammars, we formulate rules like "if Alice can X then X is a verb". This X is a box, also called variable, for any right word. Let's say, we want to create a meaningful sentence. As an input, we have a fixed part of the sentence in boxes and an empty box for our X. The grammar is also stored in some boxes. If in our grammar a premise, the part between the "if" and "then", fits without conflict, the posterior, the part after the "then" is now also a constraint on our box X. If somewhere in our grammar we stated that "if X is a verb then X=(do anything)", the sentence is completed to "Alice can do anything". Nice and readable.

With a bit of pondering it is quite straight forward that in a grammar, or natural language, we can express everything we need for our box computers, so they can be used as a programming language. Furthermore, they have the great upside that we do not need to care for order of execution. This is one of the major problems with sequential languages. We always have to keep in mind what's going on first. With logical languages, in the best scenario, everything is just happening at the same time. 
